-
connexion d'un client IRC

NICK <nickname>
pseudo public unique

USER <username> <hostname> <servername> <realname>
identification d'un utilisateur (pas besoin d'être unique)
on peut utiliser la variable USER de l'utilisateur qui se connecte par exemple

<hostname>
historiquement c'est le nom de la machine cliente mais on peut l'écraser par l’[IP = hostname] du client
exemple : localhost

<servername>
historiquement c'est le nom du serveur mais normalement on pourra hardcoder le nom qu'on veut
exemple : irc.local

<realname> c'est un texte libre
-
les commandes IRC

il y a toujours un prefixe sous entendu ou explicite devant les commandes
format : nickname!username@hostname

JOIN #canal

PART #canal
quitter le canal

PRIVMSG <cible> : message

NOTICE <cible> : message
comme PRIVMSG mais utilisé pour des infos système

PING <token> / PONG <token>
garder la connexion en vie

QUIT :message
se déconnecter
-
les codes réponse du serveur

001
bienvenue

353
liste des utilisateurs d'un canal

433
pseudo déjà utilisé
-

-
serveur IRC

créer un socket, l'associer à l'IP et le port 6667 et écouter sur le port 6667

accepter et établir les connexions des clients

1 seul socket qui sert juste à faire "listen"

quand un client arrive, le serveur accepte la connexion, ce qui crée un nouveau socket indépendant dédié à ce client. le socket principal (listen) reste en attente pour d'autres clients. côté client, chaque client a son propre socket.
-
un socket réseau est définie par :
IP locale + Port local, IP distante + Port distant, Protocole

exemple :
[Client : 192.168.1.25:49152]
<- TCP ->
[Serveur : 192.168.1.10:6667]
-
#include <arpa/inet.h>
pour tout ce qui est socket
-
créer un socket

int sockfd = socket(int domain, int type, int protocol);

le paramètre domain
identifie les familles d'adresses que le socket va utiliser
AF_INET → IPv4
AF_INET6 → IPv6
AF_UNIX → socket unix (communication entre processus sur la même machine, pas d’IP)
on peut aussi mettre PF_INET et PF_INET6, c’est presque pareil
historiquement, PF_ = protocol family, AF_ = address family

le paramètre type de communication
SOCK_STREAM pour TCP (on garantit l'arrivée et l'ordre)
SOCK_DGRAM pour UDP. c'est plus rapide mais la connexion n'est pas fiable comme avec TCP
SOCK_RAW. c'est rare, réservé aux programmes systèmes comme ping. on accède directement aux paquets réseau

le paramètre protocol
ça précise le protocol qu'on utilise selon les deux premiers paramètres
généralement on met 0 pour choisir le protocole par défaut

nous on fera : int sockfd = socket(AF_INET, SOCK_STREAM, 0);
-
struct sockaddr_in {
    sa_family_t    sin_family; // la famille d'adresses (exemple : AF_INET)
    in_port_t      sin_port;   // port
    struct in_addr sin_addr;   // adresse
    unsigned char  sin_zero[8]; // padding (pas utilisé)
};
struct in_addr {
    uint32_t s_addr;  // adresse IPv4 (ex : 127.0.0.1)
};

"sockaddr" → socket address
"in" → internet

c'est une structure qui permet de stocker une adresse IPv4

il existe une structure similaire pour l'IPv6 qui s'appelle sockaddr_in6

on peut la caster en (struct sockaddr*), une structure plus générique, pour l'envoyer à bind, connect, accept, sendto, etc

pour remplir sin_port, on doit utiliser : htons(8080)
"htons" → host to network short
par "network", on veut parler du "network byte order", c'est-à-dire, l'ordre des octets attendu sur le réseau. en effet, la majorité des PC sont en mode little endian (ils stockent les nombres à l'envers) alors qu'internet utilise du big endian
short → sur 2 octets
si une machine est déjà en big endian, htons ne change pas le nombre

il existe aussi htonl pour "long" <-> 32 bits. ça permet de convertir les adresses IPv4 little endian en adresse IPv4 big endian.

exemple :

addr.sin_port = htons(8080);
addr.sin_addr.s_addr = htonl(0x7F000001); // 127.0.0.1

à l'inverse, on a ntohs et ntohl pour passer du big endian à l'ordre de l'hote.
-
la fonction bind

"attacher" un socket à une sockaddr

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

pour addrlen on peut utiliser sizeof(*addr)
-
la fonction listen

passer le socket en mode écoute

int listen(int sockfd, int backlog);

backlog c'est le nombre max de connexions en attente que le noyau peut accepter. s'il y a plus de clients qui arrivent en même temps, certains recevront une erreur (ECONNREFUSED).

métaphore d'une salle d'attente entre "listen" et "accept". backlog c'est la capacité max de cette salle d'attente. dès qu'un client est traité avec accept, il quitte la zone.
-
la fonction accept

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

on lui donne :
● le socket d'écoute
● une structure vide qui contiendra la sockaddr du client qui a été accepté (+ sa taille). si on a pas besoin de savoir ça, on peut mettre null (et 0)

elle bloque le programme. elle attend des clients. elle prend le premier client de la file d'attente et crée un nouveau socket qui servira à dialoguer avec lui (sans toucher au socket d'écoute). elle rend le fd du nouveau socket.

on peut utiliser le fd du socket client pour recevoir des messages (avec la fonction read) et envoyer des messages (avec la fonction write)

exemple simple : traiter un client à la fois : boucle infinie qui fait :
● accept
● traitements avec le fd du socket client
● close le fd du socket client
-
1 socket TCP => 2 buffers gérés par le noyau :
● send buffer (= tampon d'envoi)
● recv buffer (= tampon de réception)
-
read <-> recv → "receive"
write <-> send

ils sont tous bloquants de base, sauf si le fd est en mode non bloquant globalement (avec fnctl)

recv et send sont des versions spécialisées de write et read adaptées aux sockets. ils sont recommandés et offre un paramètre supplémentaire (int) pour ajouter des flags.

exemples de flags pour recv :
● MSG_PEEK : regarder les données sans les consommer. la prochaine lecture de recv retournera les mêmes données. utile pour voir si un message est complet avant de le lire vraiment.
● MSG_WAITALL : attendre que le tampon soit complété selon la taille exact du buffer qu'on donne en paramètre (ou que la connexion se ferme). utile quand on veut exactement N octets.
● MSG_DONTWAIT : rendre l'appel non bloquant (meme si le socket est en mode bloquant).

recv en mode non bloquant :
si aucune donnée n'est dispo via le fd, renvoie -1 et errno = EAGAIN ou EWOULDBLOCK (selon le système)

pour send :
● MSG_DONTWAIT : pareil
● MSG_NOSIGNAL : n'envoie pas SIGPIPE si on tente d'écrire sur un socket fermé
● MSG_MORE : indiquer au noyau qu'il y aura encore d'autre envois après. c'est une question d'optimisation, pour regrouper les envoies fragmentés d'un gros message

quand on utilise send / write sur un socket TCP, les données passent par un tampon kernel appelé le "send buffer". c'est ça que TCP traite (découpage en segments, gérer les accusés de réception, retransmission si besoin etc).
si ce buffer est plein, de base, send attend (= se bloque) jusqu'à ce qu'il y ait de nouveau de la place dedans.

send en mode non bloquant :
si le buffer du kernel est plein, on renvoie -1 et errno = EAGAIN ou EWOULDBLOCK (selon le système)
-
fonction connect

plutôt pour le client IRC. ça permet de connecter le socket du client à celui du serveur.

int sockfd = socket(AF_INET, SOCK_STREAM, 0);
connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr));
-
commande nc

→ "netcat"

c’est un petit utilitaire en ligne de commande qui sait agir comme client ou serveur TCP / UDP

exemples :
● nc 127.0.0.1 6667
● nc localhost 6667

en gros, ça fait un connect puis :
● tout ce qu'on tape dans le terminal est envoyé avec send
● tout ce qui est envoyé aux clients par le serveur est affiché dans le terminal avec recv

on peut aussi simuler un serveur avec l'option -l :
nc -l 6667

donc on peut faire un minichat entre deux terminaux :
● serveur : nc localhost 6667 -l
● client : nc localhost 6667
-
traiter plusieurs clients en parallèle

on peut faire plusieurs processus mais c'est interdit pour nous

mettre un socket en mode non-bloquant avec O_NONBLOCK avant de l'envoyer à :
● accept + aucun client -> return EAGAIN
● recv + pas de données reçues -> return EAGAIN
● send + tampon d'envoi plein -> return EAGAIN

on combine ça avec un [poll / select / epoll / kqueue] (selon l'OS)

ça permet de savoir quand et quel descripteurs de fichiers sont prêts

on lui donne la liste des fd des sockets

on peut savoir si :
● lire (<-> recv) sur un fd, si POLLIN est signalé
● écrire (<-> send) sur un fd, si POLLOUT est signalé
● il y a une erreur avec ce fd POLLERR/POLLHUP

poll bloque jusqu'à ce qu'au moins un fd soit prêt (ou qu'un délait expire). comme ça, on ne fait accept que si le socket d'écoute est lisible ie il a POLLIN




-
questions

● explique moi "address.sin_addr.s_addr = INADDR_ANY;". si je fais un serveur irc en local, je dois mettre l'adresse ip localhost ou bien c'est pareil ? plus restrictif ? moins restrictif ? c'est quoi la différence ?

● explique moi ça :
printf("Connexion acceptée d’un client avec IP %s et port %d\n",
       inet_ntoa(cli_addr.sin_addr), ntohs(cli_addr.sin_port));


