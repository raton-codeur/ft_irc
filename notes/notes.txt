-
architecture des classes

CommandHandler
une instance publique, initialisée avec le serveur (et stockée dans le serveur)

quand on crée un client, on lui passe une ref privée au serveur (et donc au command handler) + une ref aux events qu'on veut surveiller avec poll

le cmdHandler s'applique sur un client donc il a toutes les méthodes publiques du client + une ref à l'inbox du client



une boucle run du Serveur :
- acceptClients : accepter des clients
- handleClientEvents : gérer les buffers du clients, c'est-à-dire, reçevoir et envoyer. on lance peut-être des commandes et on note peut petre des clients à supprimer. on ne supprime pas directement de clients ici.
- removeClients : supprimer des clients (si on a plus rien à leur envoyer ou hardDisconnect)



client
attributs :
- _softDisconnect
- _hardDisconnect
getters :
- isSoftDisconnect
- isHardDisconnect

passage en soft disconnect : setSoftDisconnect
le client est toujours connecté mais on va le supprimer
il faut arrêter de surveiller son POLLIN car on arrête de le lire
on ne touche pas son POLLOUT car on va finir de lui envoyer son outbox avant de le déconnecter

passage en hard disconnect : setHardDisconnect
le client n'est plus connecté, on va le supprimer
on pourrait arrêter de surveiller son POLLIN, arrêter de surveiller son POLLOUT, le passer en softDisconnect, mais on va le supprimer tout de suite donc osf






handleClientEvents
(si un client est en soft disconnect, poll ne surveille pas son POLLIN)
- si le client trigger une erreur poll, on le passe en hard disconnect et on passe au client suivant. il sera déco par remove clients tout de suite
- si le client passe en soft disconect dans handlePOLLIN, on va handlePOLLOUT jusqu'à ce que son outbox soit vide (tout de suite ou en plusieurs fois) puis il se fera déco dans removeClients (si on repasse par handleClientEvents, on ne refait pas handlePOLLIN).
- si le client passe en hard disconnect dans handlePOLLIN, on passe au client suivant et il se fera déco tout de suite par removeClients.





handlePOLLIN peut passer le client en soft / hard disconnect

- si le client s'est déconnecté, on le marque pour hard disconnect et on passe au suivant
- si on a eu SIGINT, on revient au main
- si on a eu un autre signal, on refait recv
- si c'est un faux POLLIN, on passe au suivant
- si on a eu une autre erreur de recv, on marque le client hard disconnect et on passe au suivant




attributs :
- _BUFFER_RECV_SIZE (1024)
- _bufferRecv[_BUFFER_RECV_SIZE] (tableau de char)
- _inbox (string)
- _MAX_RECV_PER_CLIENT (2048)
- _MAX_LINE_LENGTH (512)


- boucle sur les clients → pour un client donné qui a trigger POLLIN :
	- boucle sur recv. on ajoute au plus 2048 char à l’inbox
	- on parse l’inbox à la recherche de commande et on les exécute









outbox d'un client
c'est une deque de string
quand on veut envoyer un message à un client, on fait client.send(message). ça ajoute le message à l'outbox (outbox.push_bash(message)) et ça trigger POLLOUT pour savoir quand on peut écrire au client. on met pas \r\n à la fin du message

handlePOLLOUT

ça indique qu'il y a quelque chose dans l'outbox du client à envoyer.
on veut faire une boucle : tant que l'outbox n'est pas vide :
- send(outbox.front())
- outbox.pop_front()
puis désactiver POLLOUT

on a _outboxOffset en plus de _outbox
de base c'est 0
c'est l'indice dans [le front de _outbox] du début de ce qu'il faut send








-
plus tard

revoir delete client dans le serveur pour supprimer le client des channels, notifier les autres clients

méthode client.disconnect ?
on a server.delete(index d'un client)

paramètre pour markToDisconnect : une chaine "why" pour pouvoir faire :
_outbox.push_back("ERROR :Closing Link: " + _nick + " (" + why + ")\r\n");

paramètre pour markHardDisconnect : une chaine "why" pour faire :
std::cerr << "[ERROR] Client " << _nick << " disconnected: " << why << std::endl;

il faut disable POLLIN lors d'un [soft / hard] disconnect
on arrêter de lire un client quand on va le déconnecter. pour un soft, on continue de lui écrire.
ça simplifie cette ligne dans handleClientEvents : if (_poll_array[i].revents & POLLIN && !_clients[i]->isToDisconnect())









cmdHandler

checkInbox

quand on reçoit des données dans le buffer d'un client, il faut parser le buffer.
on ajoute "handle buffer" à la classe "handle command".

on appelle "handle buffer" pour voir si :
- on a pas dépassé le "max client input buffer"
- on a des lignes à traiter (il y a \n ou \r\n)
- chaque ligne ne dépasse pas "max line length"

handle buffer renvoie 0 sauf si on a marqué le client pour suppression (et donc qu'on arrête de lire son inbox)

si il y a une ligne à traiter, il faut la split en arguments et appeler la bonne fonction avec les arguments
