-
les sockets du serveur IRC

1) créer un socket TCP
2) associer le socket à l'IP du serveur + port 6667
3) passer le socket en mode "écoute" (sur le port 6667)
4) accepter et établir les connexions des clients

on a 1 seul socket qui sert à faire "listen"

quand un client arrive, le serveur accepte la connexion, ce qui crée un nouveau socket indépendant dédié à ce client. le socket principal (listen) reste en attente pour d'autres clients. côté client, chaque client a son propre socket.
-
créer un socket

int sockfd = socket(int domain, int type, int protocol);

le paramètre domain
identifie les familles d'adresses que le socket va utiliser
AF_INET → IPv4
AF_INET6 → IPv6
AF_UNIX → socket unix (communication entre processus sur la même machine, pas d’IP)
on peut aussi mettre PF_INET et PF_INET6, c’est presque pareil
historiquement, PF_ = protocol family, AF_ = address family

le paramètre type de communication
SOCK_STREAM pour TCP (on garantit l'arrivée et l'ordre)
SOCK_DGRAM pour UDP. c'est plus rapide mais la connexion n'est pas fiable comme avec TCP
SOCK_RAW. c'est rare, réservé aux programmes systèmes comme ping. on accède directement aux paquets réseau

le paramètre protocol
ça précise le protocole qu'on utilise selon les deux premiers paramètres
généralement on met 0 pour choisir le protocole par défaut

nous on fera : int sockfd = socket(AF_INET, SOCK_STREAM, 0);
-
-
la fonction bind

"attacher" un socket à une sockaddr

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

pour addrlen on peut utiliser sizeof(*addr)
-
la fonction listen

passer le socket en mode écoute

int listen(int sockfd, int backlog);

backlog c'est le nombre max de connexions en attente que le noyau peut gérer. s'il y a plus de clients qui arrivent en même temps, certains recevront une erreur (ECONNREFUSED).

métaphore d'une salle d'attente entre "listen" et "accept". backlog c'est la capacité max qu'on donne à cette salle d'attente. dès qu'un client est traité avec accept, il quitte la zone.
-
la fonction accept

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

on lui donne :
● le socket d'écoute
● une structure vide qui contiendra la sockaddr du client qui a été accepté (+ sa taille). si on a pas besoin de savoir ça, on peut mettre null (et 0)

elle bloque le programme. elle attend des clients. elle prend le premier client de la file d'attente et crée un nouveau socket qui servira à dialoguer avec lui (sans toucher au socket d'écoute). elle renvoie le fd du nouveau socket créé.

exemple simple : traiter un client à la fois : boucle infinie qui fait :
● accept
● traitements avec le fd du socket client
● close le fd du socket client
-
la fonction connect

c'est pour le client IRC. ça permet de se connecter au socket du serveur.

● créer un socket vide. on obtient un fd qui servira à communiquer avec le serveur
● connecter le socket à l'IP du serveur grâce à la fonction connect. on est bloqué (par défaut) par connect tant que la connexion n'est pas établie
● on peut utiliser le fd de la socket pour communiquer

exemple :
int sockfd_serv = socket(AF_INET, SOCK_STREAM, 0);
connect(sockfd_serv, (struct sockaddr*)&server_addr, sizeof(server_addr));
send(sockfd, "NICK Quentin\r\n", 15, 0);
recv(sockfd, buffer, sizeof(buffer), 0);
-
