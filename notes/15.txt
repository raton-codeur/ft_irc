-
architecture des classes

CommandHandler
une instance publique, initialisée avec le serveur (et stockée dans le serveur)

quand on crée un client, on lui passe une ref privée au serveur (et donc au command handler) + une ref aux events qu'on veut surveiller avec poll

le cmdHandler s'applique sur un client donc il a toutes les méthodes publiques du client + une ref à l'inbox du client



une boucle run du Serveur :
- acceptClients : accepter des clients
- handleClientEvents : gérer les buffers du clients, c'est-à-dire, reçevoir et envoyer. on lance peut-être des commandes et on note peut petre des clients à supprimer. on ne supprime pas directement de clients ici.
- removeClients : supprimer des clients (si on a plus rien à leur envoyer ou hardDisconnect)



client
attributs :
- _softDisconnect
- _hardDisconnect
getters :
- isSoftDisconnect
- isHardDisconnect

passage en soft disconnect : setSoftDisconnect
le client est toujours connecté mais on va le supprimer
il faut arrêter de surveiller son POLLIN car on arrête de le lire
on ne touche pas son POLLOUT car on va finir de lui envoyer son outbox avant de le déconnecter
paramètre : une chaine de log pour le serveur et une chaine de log pour le client. on stocke la chaine de log pour le serveur dans _disconnectLog et on le serveur l'affichera au moment où il fait deleteClient. la chaine de log pour le client est ajoutée à l'outbox du client

passage en hard disconnect : setHardDisconnect
le client n'est plus connecté, on va le supprimer
on pourrait arrêter de surveiller son POLLIN, arrêter de surveiller son POLLOUT, le passer en softDisconnect, mais on va le supprimer tout de suite donc osf
paramètre : une chaine de log pour le serveur. on la stocke dans _disconnectLog et on l'affiche au moment où on appelle deleteClient





handleClientEvents
(si un client est en soft disconnect, poll ne surveille pas son POLLIN)
- si le client trigger une erreur poll, on le passe en hard disconnect et on passe au client suivant. il sera déco par remove clients tout de suite
- si le client passe en soft disconect dans handlePOLLIN, on va handlePOLLOUT jusqu'à ce que son outbox soit vide (tout de suite ou en plusieurs fois) puis il se fera déco dans removeClients (si on repasse par handleClientEvents, on ne refait pas handlePOLLIN).
- si le client passe en hard disconnect dans handlePOLLIN, on passe au client suivant et il se fera déco tout de suite par removeClients.





handlePOLLIN peut passer le client en soft / hard disconnect

- si le client s'est déconnecté, on le marque pour hard disconnect et on passe au suivant
- si on a eu SIGINT, on revient au main
- si on a eu un autre signal, on refait recv
- si c'est un faux POLLIN, on passe au suivant
- si on a eu une autre erreur de recv, on marque le client hard disconnect et on passe au suivant



attributs :
- _BUFFER_RECV_SIZE (1024)
- _bufferRecv[_BUFFER_RECV_SIZE] (tableau de char)
- _inbox (string)
- _MAX_RECV_PER_CLIENT (2048)
- _MAX_LINE_LENGTH (512)


- boucle sur les clients → pour un client donné qui a trigger POLLIN :
	- boucle sur recv. on ajoute au plus 2048 char à l’inbox
	- on parse l’inbox à la recherche de commande et on les exécute



cmdHandler.parseAndExecute(ref au client, ref à l'inbox du client)
	si on trouve une ligne complète dans l'inbox
		vérifier que la ligne fasse moins de 512 char. sinon, on setHardDisconnect et on quitte
		split la ligne en arguments
		appeler la bonne fonction sur client + arguments








outbox d'un client

c'est une deque de string

quand on veut envoyer un message à un client, on fait client.send(message). ça ajoute le message à l'outbox (outbox.push_bash(message)) et ça trigger POLLOUT pour savoir quand on peut écrire au client. on met pas \r\n à la fin du message



handlePOLLOUT

ça indique qu'il y a quelque chose dans l'outbox du client à envoyer.
on veut faire une boucle : tant que l'outbox n'est pas vide :
- send(outbox.front())
- outbox.pop_front()
puis désactiver POLLOUT

on a _outboxOffset en plus de _outbox
de base c'est 0
c'est l'indice dans [le front de _outbox] du début de ce qu'il faut send








-
plus tard



revoir delete client dans le serveur pour supprimer le client des channels, notifier les autres clients

méthode client.disconnect ?
on a server.delete(index d'un client)












